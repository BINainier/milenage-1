/**
 * Copyright (c) 2016 Constantin Roganov
 * <p/>
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 * and associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * <p/>
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 * <p/>
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
 * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package threegpp.milenage;

import javax.crypto.Cipher;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

/**
 * <h1>Milenage</h1>
 * Milenage algorithm
 * <p>
 * Implements all Milenage functions according 3GPP TS 35.206
 * <p>
 * @author Constantin Roganov {@literal <rccbox @ gmail . com>}
 * @version 1.0.0
 * @since 07.02.16
 */
public class Milenage<T> {

    public static final short CONST_NUM = 5;
    public static final short BLOCK_LEN_BYTES = 16;
    public static final short HALF_BUFFER_BYTES = 8;
    public static final short AK_LENGTH_BYTES = 6;
    public static final short BLOCK_LEN_BITS = BLOCK_LEN_BYTES * 8;
    public static final short SQN_LEN_BYTES = 6;
    public static final short AK_LEN_BYTES = SQN_LEN_BYTES;
    public static final short AMF_LEN_BYTES = 2;

    private MilenageBuffer<T> opc;
    private Cipher key;
    private Constants<MilenageBuffer<T>> c;
    private RConstants r;

    /**
     * Creates OPc from OP and K
     * <p>
     * OPC = OP ⊕ E[OP]K
     * <p>
     * @param op  Operator Variant Algorithm Configuration Field (128 bit)
     * @param k  {@link javax.crypto.Cipher} object representing the Subscriber Key
     * @param <T>  The type used by {@link MilenageBuffer} implementation
     * @return  {@link MilenageBuffer} representing calculated OPc value
     */
    public static <T> MilenageBuffer<T> calculateOPc(final MilenageBuffer<T> op, final Cipher k) {
        return op.encrypt(k).xor(op);
    }

    /**
     * Constructor
     *
     * @param OPc  Buffer containing OPc value (OPc = OP⊕E[OP]K)
     * @param cipher  {@link javax.crypto.Cipher} representing the encryption key (K)
     * @param cConstants  Block of C constants (C1...C5)
     * @param rConstants  Block of R constants (R1...R5)
     */
    public Milenage(MilenageBuffer<T> OPc, Cipher cipher,
                    CConstants<T> cConstants, RConstants rConstants) {
        opc = OPc;
        key = cipher;
        c = cConstants;
        r = rConstants;
    }

    /**
     * Calculates result of Milenage functions f1 and f1*
     * <p>
     * Output of f1 = MAC-A, where MAC-A[0] .. MAC-A[63] = OUT1[0] .. OUT1[63]
     * <p>
     * Output of f1* = MAC-S, where MAC-S[0] .. MAC-S[63] = OUT1[64] .. OUT1[127]
     *
     * @param rand  Random value generated by network (RAND)
     * @param in1   A 128-bit value IN1 is constructed as follows:<p>
     *                  IN1[0] .. IN1[47] = SQN[0] .. SQN[47]<p>
     *                  IN1[48] .. IN1[63] = AMF[0] .. AMF[15]<p>
     *                  IN1[64] .. IN1[111] = SQN[0] .. SQN[47]<p>
     *                  IN1[112] .. IN1[127] = AMF[0] .. AMF[15]<p>
     * @return  Map containing results of f1 and f1* with keys {@link MilenageResult#MAC_A} and
     *          {@link MilenageResult#MAC_S} accordingly.
     */
    public Map<MilenageResult, byte []> f1All(MilenageBuffer<T> rand,
                                              MilenageBuffer<T> in1) {
        return makeF1Result(out1(temp(rand), in1));
    }

    /**
     * Calculates result of Milenage functions f2 and f5
     * <p>
     * Output of f2 = RES, where RES[0] .. RES[63] = OUT2[64] .. OUT2[127]
     * <p>
     * Output of f5 = AK, where AK[0] .. AK[47] = OUT2[0] .. OUT2[47]
     *
     * @param rand  Random value generated by the network (RAND)
     * @return  Map containing results of f2 and f5 with keys {@link MilenageResult#RES} and
     *          {@link MilenageResult#AK} accordingly.
     */
    public Map<MilenageResult, byte []> f2f5(MilenageBuffer<T> rand) {

        return makeF2F5Result(outX(temp(rand), 1));
    }

    /**
     * Calculates result of Milenage function f3
     * <p>
     * Output of f3 = CK, where CK[0] .. CK[127] = OUT3[0] .. OUT3[127]
     *
     * @param rand  Random value generated by the network (RAND)
     * @return  Buffer containing CK value
     */
    public byte[] f3(MilenageBuffer<T> rand) {
        return outX(temp(rand), 2).toBytes();
    }

    /**
     * Calculates result of Milenage function f4
     * <p>
     * Output of f4 = IK, where IK[0] .. IK[127] = OUT4[0] .. OUT4[127]
     *
     * @param rand  Random value generated by the network (RAND)
     * @return  Buffer containing IK value
     */
    public byte [] f4(MilenageBuffer<T> rand) {
        return outX(temp(rand), 3).toBytes();
    }

    /**
     * Calculates result of Milenage function f5*
     * <p>
     * Output of f5* = AK, where AK[0] .. AK[47] = OUT5[0] .. OUT5[47]
     *
     * @param rand  Random value generated by the network (RAND)
     * @return  Buffer containing resynch AK value
     */
    public byte [] f5Star(MilenageBuffer<T> rand) {
        return makeF5StarResult(outX(temp(rand), 4));
    }

    /**
     * Calculates all the Milenage function values.
     * <p>
     * Calculation can be performed synchronously or asynchronously.
     *
     * @param rand  Random value generated by the network (RAND)
     * @param in1   A 128-bit value IN1 is constructed as follows:<ul>
     *                  <li>IN1[0] .. IN1[47] = SQN[0] .. SQN[47]
     *                  <li>IN1[48] .. IN1[63] = AMF[0] .. AMF[15]
     *                  <li>IN1[64] .. IN1[111] = SQN[0] .. SQN[47]
     *                  <li>IN1[112] .. IN1[127] = AMF[0] .. AMF[15]</ul>
     * @param executor  {@link ExecutorService} object to be used for calculations.
     * @return  Map containing results of f1, f1*, f2, f3, f4, f5, f5* marked with appropriate
     *          key from {@link MilenageResult} enum.
     * @throws InterruptedException  can be thrown by the {@link ExecutorService}
     * @throws ExecutionException  can be thrown by the {@link ExecutorService}
     */
    public Map<MilenageResult, byte []> calculateAll(MilenageBuffer<T> rand,
                                                     MilenageBuffer<T> in1,
                                                     ExecutorService executor)
                                throws InterruptedException, ExecutionException {
        MilenageBuffer<T> tmp = temp(rand);

        List<Callable<MilenageBuffer<T>>> routines = new ArrayList<>();
        routines.add(getOUT1Callable(tmp, in1));

        int [] indexes = new int[] {1, 2, 3, 4};
        for(int i: indexes) {
            routines.add(getOUTXCallable(tmp, i));
        }
        List<Future<MilenageBuffer<T>>> futures =  executor.invokeAll(routines);
        Map<MilenageResult, byte []> result = new HashMap<>(CONST_NUM);

        result.putAll(makeF1Result(futures.get(0).get()));
        result.putAll(makeF2F5Result(futures.get(1).get()));
        result.put(MilenageResult.CK, futures.get(2).get().toBytes());
        result.put(MilenageResult.IK, futures.get(3).get().toBytes());
        result.put(MilenageResult.AK_R, makeF5StarResult(futures.get(4).get()));

        return result;
    }

    /**
     * Calculates intermediate parameter TEMP
     * <p>
     * TEMP = E[RAND ⊕ OPC]K
     * <p>
     * @param rand  Network generated random value (RAND)
     * @return  A buffer containing TEMP value
     */
    private MilenageBuffer<T> temp(MilenageBuffer<T> rand) {
        return rand.xor(opc).encrypt(key);
    }

    /**
     * Calculates the intermediate Milenage parameter OUT1
     * <p>
     * OUT1 = E[TEMP ⊕ rot(IN1 ⊕ OPC, r1) ⊕ c1]K ⊕ OPC
     * <p>
     * @param tmp  Intermediate parameter {@link Milenage#temp(MilenageBuffer) TEMP}
     * @param in1   A 128-bit value IN1 is constructed as follows:
     *                  IN1[0] .. IN1[47] = SQN[0] .. SQN[47]
     *                  IN1[48] .. IN1[63] = AMF[0] .. AMF[15]
     *                  IN1[64] .. IN1[111] = SQN[0] .. SQN[47]
     *                  IN1[112] .. IN1[127] = AMF[0] .. AMF[15]
     * @return  Buffer containing calculated OUT1 value
     */
    private MilenageBuffer<T> out1(MilenageBuffer<T> tmp,
                                   MilenageBuffer<T> in1) {
        return in1
                .xor(opc)
                .leftCircularBitRotation(r.get(0))
                .xor(tmp)
                .xor(c.get(0))
                .encrypt(key)
                .xor(opc);
    }

    /**
     * Calculates the intermediate Milenage parameter OUTx (where x[2...5])
     *
     * @param tmp  Intermediate Milenage parameter
     * @param constIndex  Zero based index of appropriate R and C constant values.
     * @return  A buffer containing appropriate OUT value
     */
    private MilenageBuffer<T> outX(MilenageBuffer<T> tmp, int constIndex) {
        return tmp
                .xor(opc)
                .leftCircularBitRotation(r.get(constIndex))
                .xor(c.get(constIndex))
                .encrypt(key)
                .xor(opc);
    }

    private Callable<MilenageBuffer<T>> getOUT1Callable(final MilenageBuffer<T> tmp,
                                                        final MilenageBuffer<T> in1Val) {
        return new Callable<MilenageBuffer<T>>() {
            public MilenageBuffer<T> call() throws Exception {
                return out1(tmp, in1Val);
            }
        };
    }

    private Callable<MilenageBuffer<T>> getOUTXCallable(final MilenageBuffer<T> tmp,
                                                        final int constIndex) {
        return new Callable<MilenageBuffer<T>>() {
            public MilenageBuffer<T> call() throws Exception {
                return outX(tmp, constIndex);
            }
        };
    }

    private Map<MilenageResult, byte []> makeF1Result(MilenageBuffer<T> buf) {
        byte [][] bytes = buf.takeBytes(
                0, HALF_BUFFER_BYTES,
                HALF_BUFFER_BYTES, BLOCK_LEN_BYTES
        );

        Map<MilenageResult, byte []> result = new HashMap<>();

        result.put(MilenageResult.MAC_A, bytes[0]);
        result.put(MilenageResult.MAC_S, bytes[1]);

        return result;
    }

    private Map<MilenageResult, byte []> makeF2F5Result(MilenageBuffer<T> buf) {
        byte [][] out2 = buf.takeBytes(
                0, AK_LENGTH_BYTES,
                HALF_BUFFER_BYTES, BLOCK_LEN_BYTES
        );
        Map<MilenageResult, byte []> result = new HashMap<>(2);

        result.put(MilenageResult.AK, out2[0]);
        result.put(MilenageResult.RES, out2[1]);

        return result;
    }

    private byte [] makeF5StarResult(MilenageBuffer<T> buf) {
        return buf.takeBytes(0, AK_LEN_BYTES)[0];
    }
}
